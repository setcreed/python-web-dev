# Redis常见面试题

## 1、什么是redis？

Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。

## 2、redis的优缺点

优点：

- Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
- Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。

缺点：

Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。

## 3、使用redis有哪些好处？

- 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

- 支持丰富数据类型，支持string，list，set，sorted set，hash

- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

- 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

## 4、Redis与MySQL中事务的区别

在MySQL中只有使用`Innodb`引擎的数据库表才支持事务

事务使用的目的是为了：统一管理`insert,update,delete`这些写操作，以此来维护数据的完整性。

### 事务命令

MySQL:

```python
begin	  #显式地开启一个事务
commit	  #提交事务，对数据库进行的所有写操作变为永久性的
rollback  #结束用户的事务，并撤销正在进行的所有未提交的写操作
```

Redis支持简单的事务

```python
multi		#标记事务的开始
exec		#执行事务的commands队列
discard		#结束事务，并清除commands队列
```

Redis和MySQL事务的对比：

| 指令 | MySQL                   | Redis                  |
| ---- | ----------------------- | ---------------------- |
| 开启 | start transaction/begin | multi                  |
| 语句 | SQL                     |                        |
| 失败 | rollback回滚            | discard取消            |
| 成功 | commit 成功             | exec执行事务的命令队列 |



  **`roolback`和`discard`的区别：**

如果开启事务了，执行SQL语句或者Redis的命令出错，rollback回滚之后，前面语句的影响消失；discard只是结束本次事务，前面语句造成的影响还在。

**在`multi`后面的语句出错可能有两种情况：**

- 语法就有问题。(这种exec时报错，所有语句都不执行)
- 语法本身没有错，但使用对象有问题。比如`zadd`命令操作`string对象`，exec之后回执行正确的语句并跳过不适当的语句。

### 实现原理

MySQL:

- mysql实现事务，是基于undo/redo日志
- undo记录修改前状态，rollback基于undo日志实现
- redo记录修改后的状态，commit基于redo日志实现
- 在mysql中无论是否开启事务，sql都会被立即执行并返回执行结果，只是事务开启后执行后状态只是记录在redo日志，执行commit之后，数据才会被写入磁盘

Redis:

- redis实现事务，是基于commands队列
- 如果没有开启事务，command将会被立即执行并返回执行结果，并且直接写入磁盘
- 如果事务开启，command不会被立即执行，而是排入队列，并返回排队状态（具体依赖于客户端自身实现）。调用exec才会执行commands队列

### 悲观锁与乐观锁

| 术语   | 描述                                                         | 示例                                           |
| ------ | ------------------------------------------------------------ | ---------------------------------------------- |
| 乐观锁 | 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据 | 版本号或时间戳控制，适用于多读少写的场景       |
| 悲观锁 | 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁 | DB的行锁、表锁等，适用于数据一致性比较高的场景 |

例子:

```python
ticket -1;
money -100;
# 票减1,钱减100
```

而如果票只有1张，如果在`multi之后exec之前`，票被其他人买走了，即ticket变为0了。
我该如何观察这种情况，并不再提交？

悲观的想法：有人和我抢，给ticket加锁，只有我能操作。(悲观锁)
乐观的想法：我只需要注意有没有人更改ticket的值就可以了。(乐观锁)

**redis的事务中，启动的是乐观锁，只负责监测key有没有被改动**

### Redis watch

Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断

以买票业务为例:

```python
redis> watch ticket				#监视ticket这个key
OK
redis> multi					#开启事务
OK
redis> decr tickert				#票减去1(注意我们这里只有一张票)
QUEUED
redis> decrby monery 100
QUEUED
redis> exec
(nil)							#返回nil说明监视的tiket已经改变了，事务就取消了
```

## 5、redis相比memcached有哪些优势？

- memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
- redis的速度比memcached快很多 
- redis可以持久化其数据

## 6、Memcache与Redis的区别都有哪些？

- 存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。
- 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

## 7、RDB与AOF的区别

RDB与AOF是两种 redis持久化的机制。用于crash后，redis的恢复。

RDB：

- fork一个进程，遍历hash table，利用copy on write，把整个db dump保存下来。
- save, shutdown, slave 命令会触发这个操作
- 粒度比较大，如果save, shutdown, slave 之前crash了，则中间的操作没办法恢复。

AOF：

- 把写操作指令，持续的写到一个类似日志文件里。（类似于从MySQLl等数据库导出sql一样，只记录写操作）
- 粒度较小，crash之后，只有crash之前没有来得及做日志的操作没办法恢复。

两种区别就是，一个是平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作；一个是持续的用日志记录写操作，crash后利用日志恢复。

选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。

## 8、redis常见性能问题和解决方案：

- Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。
- Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。
- Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。
- Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。

## 9、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：

- volatile-lru:从设置了过期时间的数据集中，选择最近最久未使用的数据释放； 
- allkeys-lru:从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放； 
- volatile-random:从设置了过期时间的数据集中，随机选择一个数据进行释放； 
- allkeys-random:从数据集中(包括了设置过期时间以及未设置过期时间)随机选择一个数据进行入释放； 
- volatile-ttl：从设置了过期时间的数据集中，选择马上就要过期的数据进行释放操作； 
- noeviction：不删除任意数据(但redis还会根据引用计数器进行释放),这时如果内存不够时，会直接返回错误。

## 10、请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。具体登录函数或功能用空函数即可，不用详细写出。

```python
import redis  
import sys  
import time  
 
r = redis.StrictRedis(host=’127.0.0.1′, port=6379, db=0)  
try:       
    id = sys.argv[1]
except:      
    print('input argument error')    
    sys.exit(0)  
if r.llen(id) >= 5 and time.time() – float(r.lindex(id, 4)) <= 3600:      
    print('you are forbidden logining')
else:       
    print('you are allowed to login')    
    r.lpush(id, time.time())    
    # login_func()
```



## 11、为什么redis需要把所有数据放到内存中?

- Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。
- 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

## 12、Redis为什么单进程单线程也那么快

1. 完全基于内存
2. 数据结构简单，对数据操作也简单
3. 使用多路 I/O 复用模型

多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。



## 13、Redis 的并发竞争问题如何解决

Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 本身没有锁的概念，Redis 对于多个客户端连接并不存在竞争，但是在业务客户端对 Redis 进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。

解决办法：

- 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。
- redis 的 setnx 实现内置的锁：要设置超时时间，防止抢占到锁的客户端因失败、崩溃或其他原因没有办法释放锁而造成死锁



14、知道 redis 的持久化吗？底层如何实现的？有什么优点缺点？

- RDB(Redis DataBase:在不同的时间点将 redis 的数据生成的快照同步到磁盘等介质上):内存到硬盘的快照，定期更新。
- RDB缺点：耗时，耗性能(fork+io 操作)，易丢失数据。
- AOF(Append Only File：将 redis 所执行过的所有指令都记录下来，在下次 redis 重启时，只需要执行指令就可以了):
- AOF缺点：体积大，恢复速度慢。bgsave 做镜像全量持久化，aof 做增量持久化。因为 bgsave 会消耗比较长的时间，不够实时，在停机的时候会导致大量的数据丢失，需要 aof 来配合，在 redis 实例重启时，优先使用 aof 来恢复内存的状态，如果没有 aof 日志，就会使用 rdb 文件来恢复。Redis 会定期做aof 重写，压缩 aof 文件日志大小。Redis4.0 之后有了混合持久化的功能，将 bgsave 的全量和 aof 的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。bgsave 的原理，fork 和 cow, fork 是指 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy onwrite，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

## 15、Redis 集群最大节点个数是多少？

16384 个

## 16、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？

**缓存穿透**：

一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

**如何避免？**：

- 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。
- 对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。

**缓存雪崩**：

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

**如何避免？**：

- 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。
- 做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期
- 不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀



## 17、redis 常见数据结构以及使用场景分析

### string

常用命令：set,get,decr,incr,mget

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。

常规key-value缓存应用；
常规计数：微博数，粉丝数等。

### hash

**常用命令：** hget,hset,hgetall 等。

hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。

```python
key=PythonUser123431242
value={
  'id': 1,
  'name': 'Reese',
  'age': 22,
  'location': 'Shanghai'
}
```



### list

**常用命令:** lpush,rpush,lpop,rpop,lrange等

list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。



### set

**常用命令：**sadd,spop,smembers,sunion 等

et 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。
比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：

```python
sinterstore key1 key2 key3     将交集存在key1内
```


### sorted set

**常用命令：** zadd,zrange,zrem,zcard等

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。
