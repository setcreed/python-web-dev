

## 变量存哪了

当我们在test.py文件里定义一个变量`x = 10`，单纯这样写只是几个字符而已，只有当python解释器运行时，才有变量这个意义。这个变量的概念是python解释器提供的。

变量在计算机内存里开辟一个小空间，小空间内存放变量值10，然后内存给这个小空间一个变量名x，x指向10。

## python垃圾回收机制

```python
x = 10
x = 11
```

变量在内存开辟一个小空间，小空间内存放变量值10，变量名x指向10。加上一段代码`x = 11`，内存会重新开辟一个空间存放11，然后x会指向11，之前x指向10的连接会断掉。这样10就成了垃圾，python会自动处理这个垃圾，释放10的内存。

![](https://cdn.jsdelivr.net/gh/setcreed/pic_img/cdn_img/20200131151742.png)

```python
name1 = 'rese'
name2 = name1
name1 = 'neo'
```

![](https://cdn.jsdelivr.net/gh/setcreed/pic_img/cdn_img/20200131151815.png)

### 引用计数

引用计数针对的是变量值， 变量值的引用次数

```python
x = 1000   # 1000的引用次数为1
y = 1000    # 1000的引用次数为2
del x   # del删除x，1000的引用次数为1
```

当一个变量值的引用计数为0时，会触发垃圾回收机制，之前的值会被回收

## 小整数池

```python
>>> x = 10
>>> id(10)
140704061711472
>>> y = x
>>> id(y)
140704061711472
>>> z = 10
>>> id(z)
140704061711472   # 内存地址

>>> x = 1000
>>> id(x)
1619602196368  # 
>>> x = 1000
>>> id(x)
1619602196496   # 这里内存地址与之前的不同
```

python实现int的时候有个小整数池，这是为了避免因创建相同的值而申请重复的内存空间带来的效率问题。

python解释器会自动定义[-5, 256]之间的 整数池，这是在内存中写死的。这个范围内的整数被全局调用时，永远不会触发垃圾回收机制。

在pycharm中，这个整数范围是扩大的，它优化了。